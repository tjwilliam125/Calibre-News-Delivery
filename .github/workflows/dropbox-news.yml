name: Dropbox News

on:
  workflow_dispatch:
  schedule:
    - cron: '0 11 * * *' # Runs at 11:00 UTC (6:00 AM CDT)

jobs:
  build:
    runs-on: ubuntu-latest
    steps:
      - name: Checkout
        uses: actions/checkout@v3

      - name: Install System Libs
        run: |
          sudo apt-get update
          sudo apt-get install -y libegl1 libopengl0 libxcb-cursor0 python3-pip

      - name: Install Python Libs
        run: pip3 install requests

      - name: Install Calibre
        run: |
          sudo -v && wget -nv -O- https://download.calibre-ebook.com/linux-installer.sh | sudo sh /dev/stdin

      - name: Fetch News
        run: |
          # 1. Standard Recipes
          ebook-convert "The Economist.recipe" "Economist.epub" --output-profile=tablet || true
          ebook-convert "The Atlantic.recipe" "Atlantic.epub" --output-profile=tablet || true
          ebook-convert "Ars Technica.recipe" "ArsTechnica.epub" --output-profile=tablet || true
          ebook-convert "Scientific American.recipe" "SciAm.epub" --output-profile=tablet || true

          # 2. Custom/Specific Recipes
          ebook-convert "GuardianUS_RSS.recipe" "GuardianUS.epub" --output-profile=tablet || true
          ebook-convert "NewYorker_Custom.recipe" "NewYorker.epub" --output-profile=tablet || true

          # 3. Technology & Crypto
          ebook-convert "Wired_Custom.recipe" "Wired.epub" --output-profile=tablet || true
          ebook-convert "HackerNews_Custom.recipe" "HackerNews.epub" --output-profile=tablet || true
          ebook-convert "ProPublica_Custom.recipe" "ProPublica.epub" --output-profile=tablet || true
          ebook-convert "BitcoinMagazine_Custom.recipe" "BitcoinMag.epub" --output-profile=tablet --tags "News, Crypto" || true
          ebook-convert "CoinDesk_Custom.recipe" "CoinDesk.epub" --output-profile=tablet --tags "News, Crypto" || true
          ebook-convert "Decrypt_Custom.recipe" "Decrypt.epub" --output-profile=tablet --tags "News, Crypto" || true

      - name: Upload to Dropbox (Smart Sync)
        env:
          KEY: ${{ secrets.DROPBOX_APP_KEY }}
          SECRET: ${{ secrets.DROPBOX_APP_SECRET }}
          REFRESH: ${{ secrets.DROPBOX_REFRESH_TOKEN }}
        run: |
          # Write Python script to file to avoid quote syntax errors
          cat << 'EOF' > smart_sync.py
          import os, sys, requests, glob, json
          from datetime import datetime

          # --- CONFIG ---
          KEY = os.environ['KEY']
          SECRET = os.environ['SECRET']
          REFRESH = os.environ['REFRESH']
          TODAY = datetime.utcnow().strftime('%Y-%m-%d')
          DELETE_OLDER_THAN_DAYS = 3

          # 1. Get Access Token
          print('Refreshing Token...')
          res = requests.post('https://api.dropbox.com/oauth2/token', data={
              'grant_type': 'refresh_token',
              'refresh_token': REFRESH,
              'client_id': KEY,
              'client_secret': SECRET
          })
          if res.status_code != 200:
              print('CRITICAL: Token Refresh Failed:', res.text)
              sys.exit(1)

          TOKEN = res.json()['access_token']
          UPLOAD_HEADERS = {'Authorization': f'Bearer {TOKEN}', 'Content-Type': 'application/octet-stream'}
          JSON_HEADERS = {'Authorization': f'Bearer {TOKEN}', 'Content-Type': 'application/json'}

          # 2. Fetch Existing File List (Used for both duplicate check AND cleanup)
          print('--- FETCHING DROPBOX FILE LIST ---')
          existing_entries = []
          has_more = True
          cursor = None
          
          while has_more:
              if cursor:
                  list_payload = {'cursor': cursor}
                  list_endpoint = 'https://api.dropboxapi.com/2/files/list_folder/continue'
              else:
                  list_payload = {'path': '', 'limit': 2000}
                  list_endpoint = 'https://api.dropboxapi.com/2/files/list_folder'

              lr = requests.post(list_endpoint, headers=JSON_HEADERS, json=list_payload)
              if lr.status_code != 200:
                  print('Error listing files:', lr.text)
                  sys.exit(1)

              data = lr.json()
              existing_entries.extend(data.get('entries', []))
              has_more = data.get('has_more', False)
              cursor = data.get('cursor', '')

          # Create a set of filenames for fast lookup
          existing_filenames = {e['name'] for e in existing_entries if e['.tag'] == 'file'}

          # 3. Smart Upload (Skip if exists)
          print('\n--- PROCESSING UPLOADS ---')
          for fpath in glob.glob('*.epub'):
              base_name = os.path.splitext(fpath)[0]
              dated_name = f'{base_name}_{TODAY}.epub'
              
              if dated_name in existing_filenames:
                  print(f"Skipping {dated_name} (Already exists)")
                  continue
              
              print(f'Uploading {dated_name}...')
              with open(fpath, 'rb') as f:
                  data = f.read()
              
              args = {'path': f'/{dated_name}', 'mode': 'overwrite', 'mute': True}
              h = UPLOAD_HEADERS.copy()
              h['Dropbox-API-Arg'] = json.dumps(args)
              
              up_res = requests.post('https://content.dropboxapi.com/2/files/upload', headers=h, data=data)
              if up_res.status_code != 200:
                  print(f'Error uploading {dated_name}:', up_res.text)

          # 4. Cleanup (Using the list we already fetched)
          print(f'\n--- CLEANUP (Files older than {DELETE_OLDER_THAN_DAYS} days) ---')
          now = datetime.utcnow()

          for entry in existing_entries:
              if entry['.tag'] == 'file':
                  try:
                      ts = datetime.strptime(entry['server_modified'], '%Y-%m-%dT%H:%M:%SZ')
                      age = (now - ts).days
                      
                      if age > DELETE_OLDER_THAN_DAYS:
                          print(f">> DELETING: {entry['name']} (Age: {age} days)")
                          del_res = requests.post('https://api.dropboxapi.com/2/files/delete_v2', headers=JSON_HEADERS, json={'path': entry['path_lower']})
                          if del_res.status_code != 200:
                              print(f"!! Failed to delete {entry['name']}: {del_res.text}")
                  except Exception as e:
                      print(f"Error checking {entry.get('name')}: {e}")
          
          print('Sync Complete.')
          EOF
          
          python3 smart_sync.py
